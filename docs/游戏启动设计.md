# 游戏启动设计

原有的cocos2dx lua启动流程大概为:

1. 初始化cocos2dx C++部分
2. 绑定cocos2dx到lua虚拟机
3. 使用lua虚拟机调用`main.lua`文件

其中`main.lua`就是游戏逻辑开始的起点，我们可以在main里面写游戏所需要的各个模块初始化，然后执行游戏逻辑。  
这种方式是可以的，`但是`由于我们游戏是分包设计的，所有的游戏文件应该是在包文件中的，所以我们不能像`3.`一样直接调用lua文件。  

现在框架的加载流程为:

1. 初始化cocos2dx C++部分
2. 绑定cocos2dx到lua虚拟机
3. 使用`FileManager::loadFilePack("boot.pack")`加载启动包文件
4. 使用lua虚拟机调用`boot.lua`文件

如上所示，在虚拟机调用lua文件前，我们执行了加载`boot.pack`包文件操作，并且我们执行的是`boot.lua`文件。  
由于我们把游戏的启动部分单独分包，所以`main.lua`会在其他包文件中(比如`main.pack`)，执行`main.lua`的部分我们放在了`boot.lua`的最后。

## 启动包`boot.pack`的作用

启动包的主要作用当然是`启动游戏`，但是我们把游戏启动部分单独分包有以下好处:

* 启动游戏时尽可能少的加载资源，由于我们游戏采用的时分包设计，所有文件都存在于包文件中，所以使用资源前需要保证其包文件已经加载。包文件加载虽然是很快的，但是毕竟还是要时间，特别时针对很大的包文件的情况。但是游戏启动时，我们不应该由于资源加载而使屏幕黑屏或者长时间黑屏。所以就有启动包`boot.pack`，它不会很大，一般是感觉不出加载时间的。
* 启动包的作用当然是不止`启动游戏`, 启动包还可以包含`游戏配置模块`(读取游戏本地和远程配置)、`游戏日志模块`(初始化日志等)、`游戏更新模块`(游戏的更新逻辑，这里不是判断更新，而是如何更新)等。启动包包含的一般是通用模块，而且是和游戏无关的。所以整个游戏的更新方式就定义在了启动包中，如果我们要改变游戏的更新方式，就直接更新这个包就完成了。
* 启动包独立，真正做到了通用的目的，其他游戏基本都可以通用。当然可能也需要有一点修改比如游戏LOGO等。

## 启动包操作流程

启动包的操作流程大概如下:

1. 如果是Debug模式，启动调试连接器。
2. 初始化启动包的通用模块。
3. 读取本地和远程配置文件。
4. 检查包文件更新。
5. 如果boot包需要更新，则更新boot包并重启启动流程。
6. 更新游戏基础包。
7. 加载游戏基础包。
8. 执行`main.lua`以运行游戏逻辑。

