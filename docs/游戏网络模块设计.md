# 游戏网络模块设计

网络应该算是现在游戏的标配了，网络游戏就不用说了，现在单机游戏也有很多有联网功能，比如对战等。目前可能使用最简单的方式就是传输JSON格式的数据，但是这种数据可能会出现以下问题；
1. 效率问题，JSON解析并不是一个简单的操作，数据量小还好，一旦数据量大，可能会出现解析造成的延时。
2. 随意性太强，因为JSON定义可以随意，这也可以算一个优点。但是如果很久以后有修改，如果没有同步的文档，这些缺省的字段可能会让你抓狂。而且要多端同步。
3. 需要额外文档，最好的情况就是写一个JSON的文档，说明各个域的定义情况。但是如果JSON定义修改了需要同步这个文档，否则这个文档可能和JSON不一致，不知道什么时候又要抓狂了。

## 需要什么样的网络模块？

虽然我没有参与过太多的网络游戏，但是如果需要我使用大量通信协议和客户端或者服务器通信，那么我一定是想要`简单`、`方便`、`安全`和`高效`的网络模块，而且最好是有直观的文档。  
这也是我们设计这个模块的目的，这个模块要新加一条协议的流程是，`编写协议文件` -> `脚本生成各种语言协议对象` -> `各种语言通过网络模块使用这条协议`。比如;

1. 新建或者修改协议文件以添加协议
   ```
   /*
	int64 扩充, 注释
    */
    struct int64 {
        int32	low;		// 低32位
        int32	high;		// 高32位
    };
   ```
2. 执行`updataProtocols.py`生成协议对象
3. 编写服务器端, 有新连接后立即发送int64协议
   ```
   netServer:addServer("server", "127.0.0.1", 8000, nil,{
        newConnect = function (netline)
            netline:writeProtocol("int64", { low = 12, high = 34 })
        end
    },true)
   ```
4. 编写客户端，注册处理int64协议
   ```
   netClient:addClient("client", "127.0.0.1", 8000, nil, nil,true)  
        :regProtHandle("int64",function (netline, name, data)
                print(name, data.low, data.high)
            end)
   ```
这样lua语言的通信处理就完成了，当然可以有其他语言，通信方式一致。


## 通信协议的定义

由于我们需要和不同语言的客户端和服务器进行通信，为了方便和自动化，我们需要定义一种通信协议的格式。
最终我们选择了类似C/C++ struct格式。最主要是简单,也可以作为协议的文档。
```
#close	protocol
#open	protocol
#command <当前命令号>
// 单行注释
/*
多行注释
*/
struct <协议名> {
    <... 协议域>
};
```
如示例协议定义文件格式:
* `#open/close	protocol` 表示打开或者关闭协议，有些struct只用于数据类型定义，如果当前协议在`close protocol`状态，那么他不能当作协议发送数据，只能是其他协议或者数据类型中的类型定义。
* `#command <当前命令号>` 表示下一条协议使用的命令号，每一条协议拥有唯一协议号。
* `<协议名>` 有效的标识符，这个是在发送和注册协议处理的唯一标识，不能重复。
* `<... 协议域>` 类似结构体数据域定义,当前的数据类型定义有;
  * **`int8`** 单字节
  * **`uint8`** 单字节无符号
  * **`int16`** 双字节
  * **`uint16`** 双字节无符号
  * **`int32`** 四字节
  * **`uint32`** 四字节无符号
  * **`float`** 单精度类型
  * **`double`** 双精度类型
  * **`string`** 字符串类型
  * **`<类型> []`** 数组类型
  * **`<自定义>`** 自定义类型, 如上面的int64数据。

由于协议中的数据类型可以自定义，当然也可以嵌套，所以基本上可以组合成所有的协议类型。
```
// 嵌套示例
struct test {
    test    t;      // 嵌套自身
}
```

## 生成各种语言协议对象

为了达到高效的目的，我们需要为每一种语言生成每一个协议的解包和打包器。在当前游戏框架中可以查看`CocosGame/game/main/src/app/main/logics/protocols/`文件夹中生成的lua版本协议对象。  
协议打包和解包器会使用程序直接解析协议的数据，没有多余的判断等操作。

## 网络通信模型

出于效率考虑，我们使用IO多路复用非阻塞socket模型。当前游戏框架的网络模块可以在`CocosGame/game/main/src/app/main/modules/network/`中查看;
* **`NetThread.lua`** 网络线程单例，主要负责管理网络线程的创建和数据通道的控制。
* **`NetServer.lua`** 网络服务器单例，理论上可以注册任意数量的服务器。
* **`NetClient.lua`** 网络客户端单例，理论上可以注册任意数量的客户端。
* **`NetLine.lua`** 网络线，这是数据发送和处理的对象，所有的数据发送和接收都应该在这个对象上进行。
* **`NetError.lua`** 网络错误定义文件，可以查找对应的错误码。
  
当然这个模块文件夹中还有其他的辅助功能文件，比如`SocketIO.lua`是一个通信对象，他处理了通信中的所有操作，加密、压缩等。

## 网络模块使用步骤

其实，在上面的int64例子运行前，我们应该是调用`NetThread:getInstance():start()`以启动网络线程，大概的使用步骤如下;
1. `NetThread:getInstance():start()` 启动网络模块线程，这个需要最开始执行，当然也可以使用`stop()`来停止网络线程。
2. `NetServer:getInstance():addServer(...)` 如果需要服务器，则使用`NetServer`注册服务器，服务器提供了很多监听接口，比如有新的网络线`NetLine`握手完成，然后就可以在网络线上，发送接收数据，或者注册监听等。`addServer`调用会返回服务器的网络线，这个网络线不能发送数据，如果调用`netline:close()`关闭后，那么这个服务器所接受的所有网络线也将关闭。
3. `NetClient:getInstance():addClient(...)` 如果需要客户端，则使用`NetClient`注册客户端，客户端也提供了很多接口，比如监听连接完成，然后就可以发送或者接收数据。`addClient`调用会返回客户端的网络线，只有在连接完成后你才能进行数据发送操作，否则可能会忽略，但是在连接完成前你就可以进行其他操作。
4. 根据具体连接的网络线`NetLine`进行数据通信操作吧，特别是协议通信操作。

